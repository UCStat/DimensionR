---
title: "Numerical Illustration"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---



```{r, warning=FALSE, message=FALSE}
#we load the packages
library(tidyverse)
library('corrr')
library(ggcorrplot)
library("FactoMineR")
library("devtools")
library(MASS)
library(caret)
library("factoextra")
library(pls)
library(ISLR)
library(class)
library(kknn)
library(laGP)
library(plgp)
library(GenSA)
library(concordance)
```




```{r}

#We compute the proportion of variation explained by the PCA's for the AS
 ProVariation = function(eignevalues){
   proVar=rep(NA, 10)
 eig=eignevalues
 for (l in 1:length(eignevalues)) {
   initV=eig[1]/sum(eig)
   nextV= sum(eig[1:l])/sum(eig)
   proVar[l]=nextV
 }
 return(proVar)
 }

 

#saparable or anisotropic Gaussian family
eps <- sqrt(.Machine$double.eps)

nlsep <- function(par, X, Y)
{
theta <- par[1:ncol(X)]
g <- par[ncol(X)+1]
n <- length(Y)
K <- covar.sep(X, d=theta, g=g)
Ki <- solve(K)
ldetK <- determinant(K, logarithm=TRUE)$modulus
ll <- - (n/2)*log(t(Y) %*% Ki %*% Y) - (1/2)*ldetK
counter <<- counter + 1
return(-ll)
}



gradnlsep <- function(par, X, Y)
{
theta <- par[1:ncol(X)]
g <- par[ncol(X)+1]
n <- length(Y)
K <- covar.sep(X, d=theta, g=g)
Ki <- solve(K)
KiY <- Ki %*% Y
## loop over theta components
dlltheta <- rep(NA, length(theta))
for(k in 1:length(dlltheta)) {
dotK <- K * distance(X[,k])/(theta[k]^2)
dlltheta[k] <- (n/2) * t(KiY) %*% dotK %*% KiY / (t(Y) %*% KiY) -
(1/2)*sum(diag(Ki %*% dotK))
}

## for g
dllg <- (n/2) * t(KiY) %*% KiY / (t(Y) %*% KiY) - (1/2)*sum(diag(Ki))
return(-c(dlltheta, dllg))
}


score <- function(Y, mu, Sigma, mah=FALSE)
{
Ymmu <- Y - mup2
Sigmai <- solve(Sigma)
mahdist <- t(Ymmu) %*% Sigmai %*% Ymmu
if(mah) return(sqrt(mahdist))
return (- determinant(Sigma, logarithm=TRUE)$modulus - mahdist)
}


# X=DataAct2[, -1] %>% as.matrix();
# y=Datatrain2[, 1] %>% as.matrix();
# XX=Acttest2 %>% as.matrix();
# yytrue=Datatest2[, 1] %>% as.matrix()
#tic <- proc.time()[3]

DimRed = function(X, y, XX, yytrue){


outg <- optim(c(rep(0.1, ncol(X)), 0.1*var(y)), nlsep,gradnlsep,
method="L-BFGS-B", lower=eps, upper=c(rep(Inf, ncol(X)), var(y)), X=X, Y=y)


K <- covar.sep(X, d=outg$par[1:ncol(X)], g=outg$par[ncol(X)+1])
Ki <- solve(K)
tau2hat <- drop(t(y) %*% Ki %*% y / nrow(X))
KXX <- covar.sep(XX, d=outg$par[1:ncol(X)], g=outg$par[ncol(X)+1])
KX <- covar.sep(XX, X, d=outg$par[1:ncol(X)], g=0)
mup2 <- KX %*% Ki %*% y
Sigmap2 <- tau2hat*(KXX - KX %*% Ki %*% t(KX))

Ymmu <- yytrue - mup2
Sigmai <- solve(Sigmap2)


#Different comparison metric 

#Root-mean-square error
RMSE=sqrt(mean(Ymmu^2))

#Root mean square error adjusted by covariance
mahdist <- t(Ymmu) %*% Sigmai %*% Ymmu
RMSE_adj_cov=sqrt(mahdist)


#Score which gives account of the magnitude of uncertainty and error accounted by the prediction
score_value=-determinant(Sigmap2, logarithm=TRUE)$modulus - mahdist

#Normalized predictive root-mean-square-error(PRMSE)
Normalized_PRMSE=RMSE/(max(y)-min(y))

#we compute NSME
Nnsme = sum(Ymmu^2)
Dnsme = sum((yytrue-mean(yytrue))^2)
NSME = 1-(Nnsme/Dnsme)

#Compute the nominal coverage
lowerC = mup2 - 1.96 * sqrt(diag(Sigmap2) %>% as.matrix())
upperC = mup2 +  1.96 * sqrt(diag(Sigmap2) %>% as.matrix())
#if((lowerC <= yytrue) & (yytrue <= upperC)){
 # answerYes =1
#}else{
  #answer=0
  #}
inside_interval <- (lowerC <= yytrue) & (yytrue <= upperC)
coverage_prob <- mean(inside_interval)


# 95% ALCI 
average_length <- mean(upperC - lowerC)

#Continuous Ranked Probability Score
# Assuming you have mean and standard deviation for each observation
mean_values <- mup2 %>% as.vector()  # Replace with your mean values
std_dev_values <-sqrt(diag(Sigmap2))  # Replace with your standard deviation values
observed_values <- yytrue %>% as.vector()  # Replace with your observed values

# Function to calculate predicted CDF for a normal distribution
calculate_normal_cdf <- function(mean, std_dev, x) {
pnorm(x, mean, std_dev)
}

# Calculate predicted CDF for each observation
predicted_cdf <- sapply(1:length(mean_values), function(i) {
calculate_normal_cdf(mean=mean_values[i], std_dev=std_dev_values[i], x=observed_values[i])
})
# Replace this with the range of values for which you want to compute the CDF
compute_crps <- function(observed, mean, std_dev) {
if (any(is.na(observed)) || any(is.na(mean)) || any(is.na(std_dev))) {
    stop("Input vectors contain NA values.")
  }
  
  if (any(is.infinite(observed)) || any(is.infinite(mean)) || any(is.infinite(std_dev))) {
    stop("Input vectors contain infinite values.")
  }

  if (length(observed) != length(mean) || length(observed) != length(std_dev)) {
    stop("Lengths of input vectors do not match.")
  }
  
  
num_obs <- length(observed)
crps_values <- numeric(num_obs)
for (i in 1:num_obs) {
    obs_i <- observed[i]
    predicted_cdf <- calculate_normal_cdf(mean[i], std_dev[i], obs_i)
    crps_values[i] <- (predicted_cdf - (obs_i <= mean[i]))^2
  }

  return(mean(crps_values))
}

# Compute CRPS
crps_score <- compute_crps(observed=observed_values, mean=mean_values, std_dev=std_dev_values)


metric=c(RMSPE=RMSE,NSME=NSME,coverage_prob=coverage_prob, ALCI=average_length, CRPS=crps_score, RMSE_adj_cov=RMSE_adj_cov,  Normalized_PRMSE=Normalized_PRMSE, score_value=score_value)

return(metric)

}


# mylhs <- function(n, d)
# {
# ## generate the Latin hypercube
# l <- (-(n - 1)/2):((n - 1)/2)
# L <- matrix(NA, nrow=n, ncol=d)
# for(j in 1:d) L[,j] <- sample(l, n)
# ## draw the random uniforms and turn the hypercube into a sample
# U <- matrix(runif(n*d), ncol=d)
# X <- (L + (n - 1)/2 + U)/n
# colnames(X) <- paste0("x", 1:d)
# ## return the design and the grid it lives on for visualization
# return(X=X)
# }


# mymaximin <- function(n, m, T=100000)
# {
# X <- matrix(runif(n*m), ncol=m) ## initial design
# d <- distance(X)
# d <- d[upper.tri(d)]
# md <- min(d)
# for(t in 1:T) {
# row <- sample(1:n, 1)
# xold <- X[row,] ## random row selection
# X[row,] <- runif(m) ## random new row
# d <- distance(X)
# d <- d[upper.tri(d)]
# mdprime <- min(d)
# if(mdprime > md) { md <- mdprime ## accept
# } else { X[row,] <- xold } ## reject
# }
# return(X)
# }

# mymaximinP <- function(n, m, T=100000, Xorig=NULL)
# { X <- matrix(runif(n*m), ncol=m) ## initial design
# d <- distance(X); d <- d[upper.tri(d)];
# md <- min(d)
# if(!is.null(Xorig)) { ## new code
# md2 <- min(distance(X, Xorig))
# if(md2 < md) md <- md2
# }
# for(t in 1:T) {
# row <- sample(1:n, 1)
# xold <- X[row,] ## random row selection
# X[row,] <- runif(m) ## random new row
# d <- distance(X); d <- d[upper.tri(d)]; mdprime <- min(d);
# if(!is.null(Xorig)) { ## new code
# mdprime2 <- min(distance(X, Xorig))
# if(mdprime2 < mdprime) mdprime <- mdprime2
# }
# if(mdprime > md) { md <- mdprime ## accept
# } else { X[row,] <- xold } ## reject
# }
# return(X)
# }



# function to obtain our data
fried <- function(n=200, d=10, a, b, Gamma, B_0, e){
 #Xd<-randomLHS(10, d)
#Xd<-mylhs(n, d)
#Xd = mymaximinP(n-10, d, T=100000, Xorig=Xdd)
#Xd=rbind(Xdd, Xd)
Xd<-mvrnorm(n, rep(0, d),  diag(10))
Z = Xd %*% B_0
Ytrue<-a*matrix(rep(1, n), nrow = n) + b*Z + Gamma *  Z^2  
Y<-Ytrue + e
data=data.frame(Xd, Y, Ytrue)
ntr2= n *0.8
nte2= n *0.2
X <- as.matrix(data[1:ntr2,1:d])
y <- drop(data$Y[1:ntr2])
ytr <- drop(data$Ytrue[1:ntr2])
XX <- as.matrix(data[(ntr2 + 1):n,1:d])
yy <- drop(data$Y[(ntr2 + 1):n])
yytrue <- drop(data$Ytrue[(ntr2 + 1):n])
datatrain<-data.frame(X, y)
datatest<-data.frame(XX, yy)
return(list(data=data,datatrain=datatrain,datatest=datatest, yytrue=yytrue, trainX=X, trainY=ytr %>% as.matrix(), testX=XX, testY=Ytrue %>% as.matrix()))
}



```





```{r}


set.seed(1000)

d=10

N=c(150, 350, 600)

b1 = c(-0.0091, -0.0579, -0.1877, 0.4774, 0.4559, -0.6714, -0.1264, -0.0082, 0.0724, -0.2308)

a = -0.16113;
b= -0.97483;
Gamma = -1.66526

B = matrix(b1, nrow = d, ncol = 1)



#Perturbation
e2=matrix(rnorm(N[1],0, 0.1^2), nrow = N[1])
e4=matrix(rnorm(N[2], 0, 0.1^2), nrow = N[2])
e6=matrix(rnorm(N[3], 0, 0.1^2), nrow = N[3])


Data2=fried(n=N[1],d=10, a=a, b=b, Gamma=Gamma, B_0=B, e=e2)
Data4=fried(n=N[2],d=10, a=a, b=b, Gamma=Gamma, B_0=B, e=e4)
Data6=fried(n=N[3],d=10, a=a, b=b, Gamma=Gamma, B_0=B, e=e6)

write.csv(Data2$trainX, file="trainX2.csv", row.names = FALSE)
write.csv(Data2$trainY, file="trainY2.csv", row.names = FALSE)
write.csv(Data2$testX, file="testX2.csv", row.names = FALSE)
write.csv(Data2$testY, file="testY2.csv", row.names = FALSE)


write.csv(Data4$trainX, file="trainX4.csv", row.names = FALSE)
write.csv(Data4$trainY, file="trainY4.csv", row.names = FALSE)
write.csv(Data4$testX, file="testX4.csv", row.names = FALSE)
write.csv(Data4$testY, file="testY4.csv", row.names = FALSE)


write.csv(Data6$trainX, file="trainX6.csv", row.names = FALSE)
write.csv(Data6$trainY, file="trainY6.csv", row.names = FALSE)
write.csv(Data6$testX, file="testX6.csv", row.names = FALSE)
write.csv(Data6$testY, file="testY6.csv", row.names = FALSE)
```






```{r}
# Load required libraries
library(ggplot2)
library(ggrepel)  # For better label placement

graph_eigen=function(eigenvalues){
# Calculate cumulative sum and convert to percentage of total
eigenvalues_df <- data.frame(
  Eigenvalue = eigenvalues,
  Component = 1:length(eigenvalues)
)
eigenvalues_df$CumulativePercentage <- cumsum(eigenvalues_df$Eigenvalue) / sum(eigenvalues_df$Eigenvalue) * 100

# Create a scree plot with optimized y-axis and label placements
scree_plot <- ggplot(eigenvalues_df, aes(x = Component, y = CumulativePercentage)) +
  geom_line() +  # Add a line graph
  geom_point() +  # Add points to the graph
  geom_text_repel(  # Use ggrepel for better label management
    aes(label = sprintf("%.2f%%", CumulativePercentage)),
    nudge_y = 2,  # Nudge labels upward for clarity
    size = 3,  # Adjust text size if necessary
    box.padding = unit(0.35, "lines"),  # Add padding around text
    point.padding = unit(0.3, "lines")  # Add padding around points
  ) +
  labs(x = "Principal Component",
       y = "Cumulative Percentage (%)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +  # Center the plot title
  scale_x_continuous(breaks = 1:10, labels = 1:10) +  # Define x-axis breaks and labels from 1 to 10
  scale_y_continuous(limits = c(0, 110), expand = c(0, 0))  # Adjust y-axis to show 0% to slightly above 100%

# Display the plot
return(print(scree_plot))
}

```



```{r}


set.seed(1000)

tic <- proc.time()[3]
resultsPCA2 <- prcomp(Data2$datatrain[, -11], scale = TRUE)
summary(resultsPCA2)
fviz_eig(resultsPCA2,
         addlabels = TRUE,
         choice="eigenvalue") +
         geom_hline(yintercept=1,
     linetype="dashed",
         color = "red")
toc <- proc.time()[3]
toc - tic

graph_eigen((resultsPCA2$sdev)^2)

# fviz_eig(resultsPCA2 , 
#          addlabels = TRUE, 
#          ylim = c(0, 70),
#          main="Figure 5: Scree Plot")


tic <- proc.time()[3]
resultsPCA4 <- prcomp(Data4$datatrain[, -11], scale = TRUE)
fviz_eig(resultsPCA4,
         addlabels = TRUE,
         choice="eigenvalue") +
         geom_hline(yintercept=1,
         linetype="dashed",
         color = "red")
summary(resultsPCA4)
toc <- proc.time()[3]
toc - tic

graph_eigen((resultsPCA4$sdev)^2)

tic <- proc.time()[3]
resultsPCA6 <- prcomp(Data6$datatrain[, -11], scale = TRUE)
fviz_eig(resultsPCA6,
         addlabels = TRUE,
         choice="eigenvalue") +
         geom_hline(yintercept=1,
         linetype="dashed",
         color = "red")
summary(resultsPCA6)
toc <- proc.time()[3]
toc-tic

graph_eigen((resultsPCA6$sdev)^2)
```


```{r}
# Load the ggplot2 library
library(ggplot2)

# Create a data frame with your data
data <- data.frame(
  PrincipalComponent = 1:10,  # Principal Components from 1 to 10
  RMSEP_or_CV_error = c(2.911453, 2.925995, 2.927791, 2.930371, 2.930800, 
                        2.930871, 2.930872, 2.930872, 2.930872, 2.930872)  # Your data points
)

# Create the plot
plot <- ggplot(data, aes(x = PrincipalComponent, y = RMSEP_or_CV_error)) +
  geom_line() +  # Connect points with a line
  geom_point() +  # Show points on the plot
  # geom_text_repel(  # Use ggrepel for better label management
  #   aes(label = sprintf("%.6f", RMSEP_or_CV_error)),
  #   nudge_y = 2,  # Nudge labels upward for clarity
  #   size = 3,  # Adjust text size if necessary
  #   box.padding = unit(0.35, "lines"),  # Add padding around text
  #   point.padding = unit(0.3, "lines")  # Add padding around points
  # ) +
  labs(x = "Principal Component", y = "RMSEP or CV_error") +
  theme_minimal() + # Use a minimal theme
  scale_x_continuous(breaks = 1:10, labels = 1:10) 

# Print the plot
print(plot)

```





```{r}

set.seed(1000)

tic <- proc.time()[3]
simPls2 <- plsr(y ~ . , ncomp = 10, data = Data2$datatrain %>% as.data.frame(),  
                scale = TRUE, validation = "LOO")
summary(simPls2)
plot(RMSEP(simPls2))
cv2=RMSEP(simPls2)
adjcv2=cv2$val[estimate= "adjCV", , ][-1] %>% as.vector()

best.dims2 <- which.min(cv2$val[estimate= "adjCV", , ]) - 1
best.dims2
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
simPls4 <- plsr(y ~ . , ncomp = 10, data = Data4$datatrain %>% as.data.frame(),
                scale = TRUE, validation = "LOO")
summary(simPls4)
plot(RMSEP(simPls4))
cv4=RMSEP(simPls4)
adjcv4=cv4$val[estimate= "adjCV", , ][-1] %>% as.vector()
best.dims4 <- which.min(cv4$val[estimate= "adjCV", , ]) - 1
best.dims4
toc <- proc.time()[3]
toc -tic


tic <- proc.time()[3]
simPls6 <- plsr(y ~ . , ncomp = 10, data = Data6$datatrain %>% as.data.frame(),
                scale = TRUE, validation = "LOO")
summary(simPls6)
plot(RMSEP(simPls6))
cv6=RMSEP(simPls6)
adjcv6=cv6$val[estimate= "adjCV", , ][-1] %>% as.vector()
best.dims6 <- which.min(cv6$val[estimate= "adjCV", , ]) - 1
best.dims6
toc <- proc.time()[3]
toc - tic
```




```{r}
tic <- proc.time()[3]
X22 = scale(Data2$datatrain[, -11] %>% as.matrix())
N2=nrow(X22)
gradF2=matrix(rep(NA, N2*d), ncol = d)
for (m in 1:d) {
gradF2[, m] = b * B[m, ] + 2 * Gamma * B[m, ]^2 * X22[, m]
}
C_sum2=list()

for (k in 1:N2) {
C_sum2[[k]]= gradF2[k,] %>% as.matrix() %*% t(gradF2[k, ])
}
list_sum2 <- Reduce("+",C_sum2)                  # Calculate sum of matrices
estimated_C2 = (1/N2) * list_sum2
DecompC2=eigen(estimated_C2)
AD2=DecompC2$values/sum(DecompC2$values)
Pvariation2 = ProVariation(eignevalues = DecompC2$values)
W2=DecompC2$vectors %>% as.matrix()
qplot(c(1:10), AD2) + 
  geom_line() + 
  xlab("Dimension") + 
  ylab("Variance Explained") +
  ggtitle("Scree Plot") +
  ylim(0, 1)+ xlim(1, 10)
toc <- proc.time()[3]
toc-tic


tic <- proc.time()[3]
X44 = scale(Data4$datatrain[, -11] %>% as.matrix())
N4=nrow(X44)
gradF4=matrix(rep(NA, N4*d), ncol = d)
for (m in 1:d) {
gradF4[, m] = b * B[m, ]  + 2 * Gamma * B[m, ]^2 * X44[, m]
}
C_sum4=list()
for (k in 1:N4) {
C_sum4[[k]]= gradF4[k,] %>% as.matrix() %*% t(gradF4[k, ])
}
list_sum4 <- Reduce("+",C_sum4)                  # Calculate sum of matrices
estimated_C4 = (1/N4) * list_sum4 
DecompC4=eigen(estimated_C4)
Pvariation4 = ProVariation(eignevalues = DecompC4$values)  
AD4=DecompC4$values/sum(DecompC4$values)
qplot(c(1:10), AD4) + 
  geom_line() + 
  xlab("Dimension") + 
  ylab("Variance Explained") +
  ggtitle("Scree Plot") +
  ylim(0, 1) + xlim(1, 10)
toc <- proc.time()[3]
toc - tic



tic <- proc.time()[3]
X66 = scale(Data6$datatrain[, -11] %>% as.matrix())
N6=nrow(X66)
gradF6=matrix(rep(NA, N6*d), ncol = d)
for (m in 1:d) {
gradF6[, m] = b * B[m, ] + 2 * Gamma * B[m, ]^2 * X66[, m]
}
C_sum6=list()
for (k in 1:N6) {
C_sum6[[k]]= gradF6[k,] %>% as.matrix() %*% t(gradF6[k, ])
}

list_sum6 <- Reduce("+",C_sum6)                  # Calculate sum of matrices
estimated_C6 = (1/N6) * list_sum6 
DecompC6=eigen(estimated_C6)
Pvariation6 = ProVariation(eignevalues = DecompC6$values)
W6=DecompC6$vectors %>% as.matrix()
AD6=DecompC4$values/sum(DecompC6$values)
qplot(c(1:10), AD6) + 
  geom_line() + geom_point(aes(x = c(1:10), y =  AD6))+
  xlab("Dimension") + 
  ylab("Variance Explained") +
  ggtitle("Scree Plot") +
  ylim(0, 1) + xlim(1, 10)
toc <- proc.time()[3]
toc-tic

```




```{r}
set.seed(1000)

counter=0

tic <- proc.time()[3]
pcaSr2= DimRed(X=resultsPCA2$x[,1:8], y=Data2$datatrain[, 11] %>% as.matrix(), 
               XX=Data2$datatest[,-11] %>% as.matrix() %*% resultsPCA2$rotation[, 1:8], 
               yytrue=Data2$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic

tic <- proc.time()[3]
pcaSr4= DimRed(X=resultsPCA4$x[,1:7], y=Data4$datatrain[, 11] %>% as.matrix(), 
               XX=Data4$datatest[,-11] %>% as.matrix() %*% resultsPCA4$rotation[, 1:7], 
               yytrue=Data4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
pcaSr6= DimRed(X=resultsPCA6$x[,1:6], y=Data6$datatrain[, 11] %>% as.matrix(), 
               XX=Data6$datatest[,-11] %>% as.matrix() %*% resultsPCA6$rotation[, 1:6], 
               yytrue=Data6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
pcaS2r2= DimRed(X=resultsPCA2$x[,1:2], y=Data2$datatrain[, 11] %>% as.matrix(), 
                XX=Data2$datatest[,-11] %>% as.matrix() %*% resultsPCA2$rotation[, 1:2], 
                yytrue=Data2$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
pcaS2r4= DimRed(X=resultsPCA4$x[,1:2], y=Data4$datatrain[, 11] %>% as.matrix(), 
                XX=Data4$datatest[,-11] %>% as.matrix() %*% resultsPCA4$rotation[, 1:2], 
                yytrue=Data4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
pcaS2r6= DimRed(X=resultsPCA6$x[,1:2], y=Data6$datatrain[, 11] %>% as.matrix(), 
                XX=Data6$datatest[,-11] %>% as.matrix() %*% resultsPCA6$rotation[, 1:2], 
                yytrue=Data6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
plsr2=DimRed(X=simPls2$scores[, 1]  %>% as.matrix(), 
             y=Data2$datatrain[, 11]  %>% as.matrix(), 
             XX=Data2$datatest[,-11] %>% as.matrix() %*% simPls2$projection[, 1], 
             yytrue=Data2$yytrue %>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
plsr4=DimRed(X=simPls4$scores[, 1]  %>% as.matrix() , 
             y=Data4$datatrain[, 11]  %>% as.matrix(), 
             XX=Data4$datatest[,-11] %>% as.matrix() %*% simPls4$projection[, 1], 
             yytrue=Data4$yytrue %>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
plsr6=DimRed(X=simPls6$scores[, 1]  %>% as.matrix(), 
             y=Data6$datatrain[, 11]  %>% as.matrix(), 
             XX=Data6$datatest[,-11] %>% as.matrix() %*% simPls6$projection[, 1], 
             yytrue=Data6$yytrue %>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
actr2=DimRed(X=X22 %>% as.matrix() %*% W2[, 1:2], 
             y=Data2$datatrain[, 11] %>% as.matrix(), 
             XX=Data2$datatest[,-11] %>% as.matrix() %*% W2[, 1:2], 
             yytrue=Data2$yytrue %>% as.matrix())
toc <- proc.time()[3]
toc - tic

tic <- proc.time()[3]
actr4=DimRed(X=X44 %>% as.matrix() %*% W2[, 1:2], 
             y=Data4$datatrain[, 11] %>% as.matrix(), 
             XX=Data4$datatest[,-11] %>% as.matrix() %*% W2[, 1:2], 
             yytrue=Data4$yytrue %>% as.matrix())
toc <- proc.time()[3]
toc - tic

tic <- proc.time()[3]
actr6=DimRed(X=X66 %>% as.matrix() %*% W2[, 1:2], 
             y=Data6$datatrain[, 11] %>% as.matrix(), 
             XX=Data6$datatest[,-11] %>% as.matrix() %*% W2[, 1:2], 
             yytrue=Data6$yytrue %>% as.matrix())
toc <- proc.time()[3]
toc - tic



g2data =read.csv("project2Ng.csv") %>% as.matrix()
g4data =read.csv("project4Ng.csv") %>% as.matrix()
g6data =read.csv("project6Ng.csv") %>% as.matrix()

gi2data =read.csv("project2Ngi.csv")%>% as.matrix()
gi4data =read.csv("project4Ngi.csv")%>% as.matrix()
gi6data =read.csv("project6Ngi.csv")%>% as.matrix()

gv2data =read.csv("project2Ngv.csv")%>% as.matrix()
gv4data =read.csv("project4Ngv.csv")%>% as.matrix()
gv6data =read.csv("project6Ngv.csv")%>% as.matrix()



tic <- proc.time()[3]
gr2= DimRed(X=Data2$datatrain[, -11] %>% as.matrix() %*% g2data, 
            y=Data2$datatrain[, 11] %>% as.matrix(), 
            XX=Data2$datatest[,-11] %>% as.matrix() %*% g2data, 
            yytrue=Data2$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
gr4= DimRed(X=Data4$datatrain[, -11] %>% as.matrix() %*% g4data, 
            y=Data4$datatrain[, 11] %>% as.matrix(), 
            XX=Data4$datatest[,-11] %>% as.matrix() %*% g4data, 
            yytrue=Data4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
gr6= DimRed(X=Data6$datatrain[, -11] %>% as.matrix() %*% g6data, 
            y=Data6$datatrain[, 11] %>% as.matrix(), 
            XX=Data6$datatest[,-11] %>% as.matrix() %*% g6data, 
            yytrue=Data6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
gir2= DimRed(X=Data2$datatrain[, -11] %>% as.matrix() %*% gi2data, 
             y=Data2$datatrain[, 11] %>% as.matrix(), 
             XX=Data2$datatest[,-11] %>% as.matrix() %*% gi2data, 
             yytrue=Data2$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic

tic <- proc.time()[3]
gir4= DimRed(X=Data4$datatrain[, -11] %>% as.matrix() %*% gi4data, 
             y=Data4$datatrain[, 11] %>% as.matrix(), 
             XX=Data4$datatest[,-11] %>% as.matrix() %*% gi4data, 
             yytrue=Data4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
gir6= DimRed(X=Data6$datatrain[, -11] %>% as.matrix() %*% gi6data, 
             y=Data6$datatrain[, 11] %>% as.matrix(), 
             XX=Data6$datatest[,-11] %>% as.matrix() %*% gi6data, 
             yytrue=Data6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
gvr2= DimRed(X=Data2$datatrain[, -11] %>% as.matrix() %*% gv2data, 
             y=Data2$datatrain[, 11] %>% as.matrix(), 
             XX=Data2$datatest[,-11] %>% as.matrix() %*% gv2data, 
             yytrue=Data2$yytrue %>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
gvr4= DimRed(X=Data4$datatrain[, -11] %>% as.matrix() %*% gv4data, 
             y=Data4$datatrain[, 11] %>% as.matrix(), 
             XX=Data4$datatest[,-11] %>% as.matrix() %*% gv4data, 
             yytrue=Data4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic

tic <- proc.time()[3]
gvr6= DimRed(X=Data6$datatrain[, -11] %>% as.matrix() %*% gv6data, 
             y=Data6$datatrain[, 11] %>% as.matrix(), 
             XX=Data6$datatest[,-11] %>% as.matrix() %*% gv6data, 
             yytrue=Data6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


pcaSr2
pcaSr4
pcaSr6


pcaS2r2
pcaS2r4
pcaS2r6




plsr2
plsr4
plsr6


actr2
actr4
actr6


gr2
gr4
gr6


gir2
gir4
gir6

gvr2
gvr4
gvr6



```


```{r}
library(ggplot2)
library(reshape2)
library(patchwork)  # Load patchwork for arranging plots

# Data Preparation
gKDR1 <- c(0.145368, 0.351702, 0.550187, 0.602102, 0.751283, 0.811140, 0.833401, 0.834410, 0.850487, 0.997203)
gKDRi1 <- c(0.012736, 0.014167, 0.129851, 0.163107, 0.203299, 0.378923, 0.451970, 0.556865, 0.58880, 0.816915)
gKDRV1 <- c(0.0168779, 0.023767, 0.030907, 0.176721, 0.288112, 0.530105, 0.621648, 0.772810, 0.919913, 0.964612)


gKDR2 <- c(0.128234, 0.266175, 0.447402, 0.688966, 0.697123, 0.766374, 0.826656, 0.903368, 0.976219, 0.980084)
gKDRi2 <- c(0.005279, 0.025839, 0.183788, 0.197487, 0.214113, 0.253439, 0.287174, 0.420978, 0.653121, 0.879273642)
gKDRV2 <- c(0.0076243, 0.0536932, 0.0170953, 0.197535, 0.227500, 0.279711, 0.287552, 0.460171, 0.516762, 0.949253)

gKDR3 <- c(0.030334, 0.057870, 0.117302, 0.144144, 0.178462, 0.478287, 0.547125, 0.801500, 0.844774, 0.997859)
gKDRi3 <- c(0.001367, 0.013756, 0.014295, 0.160517, 0.216903, 0.234015, 0.260288, 0.3682068, 0.5679432, 0.7882854)
gKDRV3 <- c(0.004979, 0.065420, 0.156806, 0.360120, 0.379671, 0.557195, 0.625408, 0.632381, 0.803013, 0.956592)

# Combining data into a data frame
data <- data.frame(Index = 1:10,
                   gKDR1 = gKDR1,
                   gKDRi1 = gKDRi1,
                   gKDRV1 = gKDRV1,
                   gKDR2 = gKDR2,
                   gKDRi2 = gKDRi2,
                   gKDRV2 = gKDRV2,
                   gKDR3 = gKDR3,
                   gKDRi3 = gKDRi3,
                   gKDRV3 = gKDRV3)

# Melting data for ggplot
data_melted <- melt(data, id.vars = "Index")


# # Plotting each case
# ggplot(data = subset(data_melted, variable %in% c("gKDR1", "gKDRi1", "gKDRV1")), aes(x = Index, y = value, color = variable)) +
#   geom_line() +
#   geom_point() +
#   ylab("RMSEP") +
#   xlab("Active Subspace") +
#   theme_minimal() + 
#   scale_x_continuous(breaks = 1:10, labels = 1:10)
# 
# ggplot(data = subset(data_melted, variable %in% c("gKDR2", "gKDRi2", "gKDRV2")), aes(x = Index, y = value, color = variable)) +
#   geom_line() +
#   geom_point() +
#   ylab("Active Subspace") +
#   xlab("Index") +
#   theme_minimal() + 
#   scale_x_continuous(breaks = 1:10, labels = 1:10)
# 
# ggplot(data = subset(data_melted, variable %in% c("gKDR3", "gKDRi3", "gKDRV3")), aes(x = Index, y = value, color = variable)) +
#   geom_line() +
#   geom_point() +
#   ylab("RMSEP") +
#   xlab("Active Subspace") +
#   theme_minimal() + 
#   scale_x_continuous(breaks = 1:10, labels = 1:10)


labels <- c(gKDR1 = "gKDR (120)", gKDRi1 = "gKDRi (120)", gKDRV1 = "gKDRV (120)",
            gKDR2 = "gKDR (280)", gKDRi2 = "gKDRi (280)", gKDRV2 = "gKDRV (280)",
            gKDR3 = "gKDR (480)", gKDRi3 = "gKDRi (480)", gKDRV3 = "gKDRV (480)")





# Data preparation, melting, and custom labels are assumed to be already defined

# Plotting each case with custom legend labels
P1 <- ggplot(data = subset(data_melted, variable %in% c("gKDR1", "gKDRi1", "gKDRV1")), aes(x = Index, y = value, color = variable)) +
  geom_line() +
  geom_point() +
  scale_color_manual(values = c("blue", "red", "green"), labels = labels) +
  ylab("RMSEP") +
  xlab("Active Subspace") +
  theme_minimal() +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  guides(color = guide_legend(title = "Method"))

P2 <- ggplot(data = subset(data_melted, variable %in% c("gKDR2", "gKDRi2", "gKDRV2")), aes(x = Index, y = value, color = variable)) +
  geom_line() +
  geom_point() +
  scale_color_manual(values = c("blue", "red", "green"), labels = labels) +
  ylab("RMSEP") +
  xlab("Active Subspace") +
  theme_minimal() +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  guides(color = guide_legend(title = "Method"))

P3 <- ggplot(data = subset(data_melted, variable %in% c("gKDR3", "gKDRi3", "gKDRV3")), aes(x = Index, y = value, color = variable)) +
  geom_line() +
  geom_point() +
  scale_color_manual(values = c("blue", "red", "green"), labels = labels) +
  ylab("RMSEP") +
  xlab("Active Subspace") +
  theme_minimal() +
  scale_x_continuous(breaks = 1:10, labels = 1:10)
  guides(color = guide_legend(title = "Method"))

# Combining the plots
combined_plot <- P1 + P2 + P3 + plot_layout(ncol = 1)  # Arrange vertically in one column
print(combined_plot)


```




```{r}
OptB2=matrix(c(0.00910139,0.05790653,0.18772296,-0.4774587, -0.45595596,0.67148236,0.12641533,0.00820117, -0.0724091, 0.23082832), ncol = 1)
OptB4=matrix(c(0.0091014, 0.0579074, 0.187723, -0.47745846, -0.45595555, 0.67148274,0.12641587, 0.00820075, -0.0724086, 0.23082813),  ncol = 1)
OptB6=matrix(c(0.00910116,0.05790733, 0.18772304,-0.47745855,-0.45595602, 0.67148238,0.12641549, 0.00820104, -0.07240888, 0.23082817),  ncol = 1)



tic <- proc.time()[3]
B2= DimRed(X=Data2$datatrain[, -11] %>% as.matrix() %*% OptB2, 
            y=Data2$datatrain[, 11] %>% as.matrix(), 
            XX=Data2$datatest[,-11] %>% as.matrix() %*% OptB2, 
            yytrue=Data2$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
B4= DimRed(X=Data4$datatrain[, -11] %>% as.matrix() %*% OptB4, 
            y=Data4$datatrain[, 11] %>% as.matrix(), 
            XX=Data4$datatest[,-11] %>% as.matrix() %*% OptB4, 
            yytrue=Data4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
B6= DimRed(X=Data6$datatrain[, -11] %>% as.matrix() %*% OptB6, 
            y=Data6$datatrain[, 11] %>% as.matrix(), 
            XX=Data6$datatest[,-11] %>% as.matrix() %*% OptB6, 
            yytrue=Data6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic
B2
B4
B6

```

```{r}
#when W is random but other parameters are fixed
#sample size 120
OptBRW2=matrix(c(-0.40166965, -0.48437645, -0.22750495, 0.01886628, -0.00504093, 0.63396805, 0.2010223, -0.11537289, -0.19639611, -0.24019431), ncol=1)
# time used
# 1.6581804752349854
# Calculate the trace of the projection
# 1.8305614313649408
# Calculate the Frobenius norm
# 1.3529824209371462




OptBRW4=matrix(c(-0.40168212,-0.48437558,-0.22750661,0.01886495, -0.0050346,0.63395927,0.20103273,-0.11536642,-0.19638499,-0.2402005), ncol = 1)
# time used
# 3.467266082763672
# Calculate the trace of the projection
# 1.8305564671553403
# Calculate the Frobenius norm
# 1.3529805863926283



OptBRW6=matrix(c(-0.40167968,-0.48437841,-0.2275073,0.01886708,-0.00504881,0.63395772,0.20102909,-0.11536478,-0.19638972,-0.24020184), ncol=1)
# time used
# 10.360366582870483
# Calculate the trace of the projection
# 1.8305463620711127
# Calculate the Frobenius norm
# 1.3529768520086043


tic <- proc.time()[3]
BRW2= DimRed(X=DataRW2$datatrain[, -11] %>% as.matrix() %*% OptBRW2, 
            y=DataRW2$datatrain[, 11] %>% as.matrix(), 
            XX=DataRW2$datatest[,-11] %>% as.matrix() %*% OptBRW2, 
            yytrue=DataRW2$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic

tic <- proc.time()[3]
BRW4= DimRed(X=DataRW4$datatrain[, -11] %>% as.matrix() %*% OptBRW4, 
            y=DataRW4$datatrain[, 11] %>% as.matrix(), 
            XX=DataRW4$datatest[,-11] %>% as.matrix() %*% OptBRW4, 
            yytrue=DataRW4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
BRW6= DimRed(X=DataRW6$datatrain[, -11] %>% as.matrix() %*% OptBRW6, 
            y=DataRW6$datatrain[, 11] %>% as.matrix(), 
            XX=DataRW6$datatest[,-11] %>% as.matrix() %*% OptBRW6, 
            yytrue=DataRW6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


BRW2
BRW4
BRW6
```



```{r}
#when W is random but other parameters fixed
#Estimated W
OptBFW2=matrix(c(0.00910148, 0.05790683, 0.18772243, -0.47745857, -0.45595613, 0.67148226, 0.12641593, 0.00820117, -0.07240885, 0.23082862), ncol=1)
# time used
# 35.13620471954346
# Calculate the trace of the projection
# 1.8279067986869495e-12
# Calculate the Frobenius norm
# 1.352001035016967e-06


#Estimated W
OptBFW4=matrix(c(0.00910064, 0.05790682, 0.1877233 , -0.47745866, -0.45595589, 0.67148231, 0.12641578, 0.00820069, -0.07240877, 0.23082824), ncol=1)
# time used
# 113.63902115821838
# Calculate the trace of the projection
# 1.1629243796502197e-12
# Calculate the Frobenius norm
# 1.0783897160350797e-06


#Estimated W
OptBFW6=matrix(c(0.0091012, 0.05790728, 0.1877228, -0.47745874, -0.45595599, 0.67148233, 0.12641554, 0.00820083,-0.07240899, 0.23082812), ncol=1)
# time used
# 417.6555526256561
# Calculate the trace of the projection
# 4.15076289725656e-13
# Calculate the Frobenius norm
# 6.442641459259207e-07


tic <- proc.time()[3]
BFW2= DimRed(X=DataFW2$datatrain[, -11] %>% as.matrix() %*% OptBFW2, 
            y=DataFW2$datatrain[, 11] %>% as.matrix(), 
            XX=DataFW2$datatest[,-11] %>% as.matrix() %*% OptBFW2, 
            yytrue=DataFW2$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
BFW4= DimRed(X=DataFW4$datatrain[, -11] %>% as.matrix() %*% OptBFW4, 
            y=DataFW4$datatrain[, 11] %>% as.matrix(), 
            XX=DataFW4$datatest[,-11] %>% as.matrix() %*% OptBFW4, 
            yytrue=DataFW4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
BFW6= DimRed(X=DataFW6$datatrain[, -11] %>% as.matrix() %*% OptBFW6, 
            y=DataFW6$datatrain[, 11] %>% as.matrix(), 
            XX=DataFW6$datatest[,-11] %>% as.matrix() %*% OptBFW6, 
            yytrue=DataFW6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic

BFW2
BFW4
BFW6
```




```{r}
##when W and other parameters are random random 
#Estimated W
OptBRRW2=matrix(c(-0.19076081, -0.51601739, 0.01759906, 0.27361026, -0.33658722,-0.16496101,-0.20363634, 0.30800131, -0.00791808,-0.58759316), ncol = 1)
# time used
# 47.18848466873169
# Calculate the trace of the projection
# 6.465080274999202e-12
# Calculate the Frobenius norm
# 2.542652212749357e-06


#Estimated W
OptBRRW4=matrix(c(-0.19076042, -0.51601754, 0.01759892, 0.27361123, -0.33658724, -0.16496115, -0.20363631, 0.30800021, -0.00791917, -0.58759322), ncol = 1)
# time used
# 134.461101770401
# Calculate the trace of the projection
# 2.822587993595235e-13
# Calculate the Frobenius norm
# 5.312803397073183e-07

OptBRRW6=matrix(c(-0.19076039, -0.5160178 , 0.01759904, 0.27361107, -0.33658728, -0.16496082, -0.2036365 , 0.30800032, -0.00791911, -0.58759302), ncol = 1)
# time used
# 621.1490862369537
# Calculate the trace of the projection
# 2.265553146012129e-13
# Calculate the Frobenius norm
# 4.759782711439808e-07



tic <- proc.time()[3]
BRRW2= DimRed(X=DataRRW2$datatrain[, -11] %>% as.matrix() %*% OptBRRW2, 
            y=DataRRW2$datatrain[, 11] %>% as.matrix(), 
            XX=DataRRW2$datatest[,-11] %>% as.matrix() %*% OptBRRW2, 
            yytrue=DataRRW2$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic



tic <- proc.time()[3]
BRRW4= DimRed(X=DataRRW4$datatrain[, -11] %>% as.matrix() %*% OptBRRW4, 
            y=DataRRW4$datatrain[, 11] %>% as.matrix(), 
            XX=DataRRW4$datatest[,-11] %>% as.matrix() %*% OptBRRW4, 
            yytrue=DataRRW4$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


tic <- proc.time()[3]
BRRW6= DimRed(X=DataRRW6$datatrain[, -11] %>% as.matrix() %*% OptBRRW6, 
            y=DataRRW6$datatrain[, 11] %>% as.matrix(), 
            XX=DataRRW6$datatest[,-11] %>% as.matrix() %*% OptBRRW6, 
            yytrue=DataRRW6$yytrue%>% as.matrix())
toc <- proc.time()[3]
toc - tic


BRRW2
BRRW4
BRRW6
```

```{r}
DimK = function(X, y, XX, yytrue, parame){


# outg <- optim(c(rep(0.1, ncol(X)), 0.1*var(y)), nlsep,gradnlsep,
# method="L-BFGS-B", lower=eps, upper=c(rep(Inf, ncol(X)), var(y)), X=X, Y=y)
# 
KernVar <- parame[ncol(X)+1]
s=parame[1:ncol(X)]
nugget <- parame[ncol(X)+2]
n1=nrow(X)
D=distance(X)
K = parame[ncol(X)+1] * exp(-0.5*D/s^2) + 0.00000001 * diag(n1)

#K <- covar.sep(X, d=parme[1:ncol(X)], g=parame[ncol(X)+1])

Ki <- solve(K)

#tau2hat <- drop(t(y) %*% Ki %*% y / nrow(X))


n2=nrow(XX)

DXX = distance(XX)
KXX = parame[ncol(XX)+1] * exp(-0.5*DXX/s^2) + 0.00000001 * diag(n2)

#KXX <- covar.sep(XX, d=outg$par[1:ncol(X)], g=outg$par[ncol(X)+1])

DXX = distance(XX, X)
KX <-  parame[ncol(XX)+1] * exp(-0.5*DXX/s^2)

mup2 <- KX %*% Ki %*% y

Sigmap2 <- KXX - KX %*% Ki %*% t(KX)

Ymmu <- yytrue - mup2

Sigmai <- solve(Sigmap2)


#Different comparison metric 

#Root-mean-square error
RMSE=sqrt(mean(Ymmu^2))

#Root mean square error adjusted by covariance
mahdist <- t(Ymmu) %*% Sigmai %*% Ymmu
RMSE_adj_cov=sqrt(mahdist)


#Score which gives account of the magnitude of uncertainty and error accounted by the prediction
score_value=-determinant(Sigmap2, logarithm=TRUE)$modulus - mahdist

#Normalized predictive root-mean-square-error(PRMSE)
Normalized_PRMSE=RMSE/(max(y)-min(y))

#we compute NSME
Nnsme = sum(Ymmu^2)
Dnsme = sum((yytrue-mean(yytrue))^2)
NSME = 1-(Nnsme/Dnsme)

#Compute the nominal coverage
lowerC = mup2 - 1.96 * sqrt(diag(Sigmap2) %>% as.matrix())
upperC = mup2 +  1.96 * sqrt(diag(Sigmap2) %>% as.matrix())
#if((lowerC <= yytrue) & (yytrue <= upperC)){
 # answerYes =1
#}else{
  #answer=0
  #}
inside_interval <- (lowerC <= yytrue) & (yytrue <= upperC)
coverage_prob <- mean(inside_interval)


# 95% ALCI 
average_length <- mean(upperC - lowerC)

#Continuous Ranked Probability Score
# Assuming you have mean and standard deviation for each observation
mean_values <- mup2 %>% as.vector()  # Replace with your mean values
std_dev_values <-sqrt(diag(Sigmap2))  # Replace with your standard deviation values
observed_values <- yytrue %>% as.vector()  # Replace with your observed values

# Function to calculate predicted CDF for a normal distribution
calculate_normal_cdf <- function(mean, std_dev, x) {
pnorm(x, mean, std_dev)
}

# Calculate predicted CDF for each observation
predicted_cdf <- sapply(1:length(mean_values), function(i) {
calculate_normal_cdf(mean=mean_values[i], std_dev=std_dev_values[i], x=observed_values[i])
})
# Replace this with the range of values for which you want to compute the CDF
compute_crps <- function(observed, mean, std_dev) {
if (any(is.na(observed)) || any(is.na(mean)) || any(is.na(std_dev))) {
    stop("Input vectors contain NA values.")
  }
  
  if (any(is.infinite(observed)) || any(is.infinite(mean)) || any(is.infinite(std_dev))) {
    stop("Input vectors contain infinite values.")
  }

  if (length(observed) != length(mean) || length(observed) != length(std_dev)) {
    stop("Lengths of input vectors do not match.")
  }
  
  
num_obs <- length(observed)
crps_values <- numeric(num_obs)
for (i in 1:num_obs) {
    obs_i <- observed[i]
    predicted_cdf <- calculate_normal_cdf(mean[i], std_dev[i], obs_i)
    crps_values[i] <- (predicted_cdf - (obs_i <= mean[i]))^2
  }

  return(mean(crps_values))
}

# Compute CRPS
crps_score <- compute_crps(observed=observed_values, mean=mean_values, std_dev=std_dev_values)


metric=c(RMSPE=RMSE,NSME=NSME,coverage_prob=coverage_prob, ALCI=average_length, CRPS=crps_score, RMSE_adj_cov=RMSE_adj_cov,  Normalized_PRMSE=Normalized_PRMSE, score_value=score_value)

return(metric)

}
```


```{r}
# ActiveSubspaceKernel.rbf.variance     |     1673.7725438926445  |      +ve      |               
#   ActiveSubspaceKernel.rbf.lengthscale  |     7.1044545545627935  |      +ve      |               
#   Gaussian_noise.variance               |  6.350707975394659e-14  | 


  
parame=c(7.1044545545627935, 1673.7725438926445, 6.350707975394659e-14)

# DimK(X=DataRRW6$datatrain[, -11] %>% as.matrix() %*% OptBRRW6,
# y=DataRRW6$datatrain[, 11] %>% as.matrix(),
# XX=DataRRW6$datatest[,-11] %>% as.matrix() %*% OptBRRW6,
# yytrue=DataRRW6$yytrue%>% as.matrix(),parame=parame)


KernVar <- parame[ncol(X)+1]
s=parame[1:ncol(X)]
nugget <- parame[ncol(X)+2]
n1=nrow(X)
D=distance(X)
K = parame[ncol(X)+1] * exp(-0.5*D/s^2) + parame[ncol(XX)+1] * 0.000001 * diag(n1)

#K <- covar.sep(X, d=parme[1:ncol(X)], g=parame[ncol(X)+1])

Ki <- solve(K)

#tau2hat <- drop(t(y) %*% Ki %*% y / nrow(X))


n2=nrow(XX)

DXX = distance(XX)
KXX = parame[ncol(XX)+1] * exp(-0.5*DXX/s^2) + parame[ncol(XX)+1] * 0.000001 * diag(n2)

#KXX <- covar.sep(XX, d=outg$par[1:ncol(X)], g=outg$par[ncol(X)+1])

DXX = distance(XX, X)
KX <-  parame[ncol(XX)+1] * exp(-0.5*DXX/s^2)

mup2 <- KX %*% Ki %*% y

Sigmap2 <- KXX - KX %*% Ki %*% t(KX)

Ymmu <- yytrue - mup2


Sigmai <- solve(Sigmap2)


Ymmu <- yytrue - mup2

Sigmai <- solve(Sigmap2)


#Different comparison metric

#Root-mean-square error
RMSE=sqrt(mean(Ymmu^2))

RMSE
```




```{r}

# we use the projection method 
BWo=matrix(c(-0.15585719, 0.25097898, 0.520428, -0.31235896, 0.62148088, -0.02533869, 0.01182028, -0.00598115, 0.20618621, -0.33872685), ncol = 1)
BW=matrix(c(-0.33920335, -0.44459527, 0.12543759, 0.13001892, 0.62128225, -0.11566746, -0.35898566, 0.08824315, -0.03828788, 0.3422609), ncol = 1)

P0= B %*% solve( t(B) %*% B) %*% t(B)
P = OptB2 %*% solve( t(OptB2) %*% OptB2) %*% t(OptB2)
sum(diag((P0-P) %*% (P0-P)))
```




```{r}
P = B %*% solve( t(B) %*% B) %*% t(B)
Ppca2= resultsPCA2$rotation[, 1:8]  %*% solve( t(resultsPCA2$rotation[, 1:8] ) %*% resultsPCA2$rotation[, 1:8] ) %*% t(resultsPCA2$rotation[, 1:8])
Ppca4= resultsPCA4$rotation[, 1:7]  %*% solve( t(resultsPCA4$rotation[, 1:7] ) %*% resultsPCA4$rotation[, 1:7] ) %*% t(resultsPCA4$rotation[, 1:7] )
Ppca6= resultsPCA6$rotation[, 1:6]  %*% solve( t(resultsPCA6$rotation[, 1:6] ) %*% resultsPCA6$rotation[, 1:6] ) %*% t(resultsPCA6$rotation[, 1:6] )


Ppls2= pl2 %*% solve( t(pl2) %*% pl2) %*% t(pl2)
Ppls4= pl4 %*% solve( t(pl4) %*% pl4) %*% t(pl4)
Ppls6= pl6 %*% solve( t(pl6) %*% pl6) %*% t(pl6)


Pas2= W2[, 1:3] %*% solve( t(W2[, 1:3]) %*% W2[, 1:3]) %*% t(W2[, 1:3])
Pas4= W4[, 1:2] %*% solve( t(W4[, 1:2]) %*% W4[, 1:2]) %*% t(W4[, 1:2])
Pas6= W6[, 1:1] %*% solve( t(W6[, 1:1]) %*% W6[, 1:1]) %*% t(W6[, 1:1])


Pg2= g2data %*% solve( t(g2data) %*% g2data) %*% t(g2data)
Pg4= g4data %*% solve( t(g4data) %*% g4data) %*% t(g4data)
Pg6= g6data %*% solve( t(g6data) %*% g6data) %*% t(g6data)


Pgi2= gi2data %*% solve( t(gi2data) %*% gi2data) %*% t(gi2data)
Pgi4= gi4data %*% solve( t(gi4data) %*% gi4data) %*% t(gi4data)
Pgi6= gi6data %*% solve( t(gi6data) %*% gi6data) %*% t(gi6data)


Pgv2= gv2data %*% solve( t(gv2data) %*% gv2data) %*% t(gv2data)
Pgv4= gv4data %*% solve( t(gv4data) %*% gv4data) %*% t(gv4data)
Pgv6= gv6data %*% solve( t(gv6data) %*% gv6data) %*% t(gv6data)

sum(diag((P-Ppca2) %*% (P-Ppca2)))
sum(diag((P-Ppca4) %*% (P-Ppca4)))
sum(diag((P-Ppca6) %*% (P-Ppca6)))


sum(diag((P-Ppls2) %*% (P-Ppls2)))
sum(diag((P-Ppls4) %*% (P-Ppls4)))
sum(diag((P-Ppls6) %*% (P-Ppls6)))


sum(diag((P-Pas2) %*% (P-Pas2)))
sum(diag((P-Pas4) %*% (P-Pas4)))
sum(diag((P-Pas6) %*% (P-Pas6)))

sum(diag((P-Pg2) %*% (P-Pg2)))
sum(diag((P-Pg4) %*% (P-Pg4)))
sum(diag((P-Pg6) %*% (P-Pg6)))


sum(diag((P-Pgi2) %*% (P-Pgi2)))
sum(diag((P-Pgi4) %*% (P-Pgi4)))
sum(diag((P-Pgi6) %*% (P-Pgi6)))


sum(diag((P-Pgv2) %*% (P-Pgv2)))
sum(diag((P-Pgv4) %*% (P-Pgv4)))
sum(diag((P-Pgv6) %*% (P-Pgv6)))
```



```{r}

# Frobenius norm to evaluate the perform between the true projection and estimated projection

Frobenius_norm =function(A){
 Fnorm=0
 for(i in 1:10){
   for(j in 1:10){
     Fnorm = Fnorm + (A[i, j])^2
   }
   
 }
  
 return(sqrt(Fnorm))

}



pb2=resultsPCA2$rotation[, 1:8] 
pb4=resultsPCA4$rotation[, 1:8]
pb6=resultsPCA6$rotation[, 1:8]


PCAB2 = pb2 %*% solve(t(pb2) %*% pb2) %*% t(pb2) - B %*% solve(t(B) %*% B) %*% t(B)
PCAB4 = pb4 %*% solve(t(pb4) %*% pb4) %*% t(pb4) - B %*% solve(t(B) %*% B) %*% t(B)
PCAB6 = pb6 %*% solve(t(pb6) %*% pb6) %*% t(pb6) - B %*% solve(t(B) %*% B) %*% t(B)

pb22=resultsPCA2$rotation[, 1:4] 
pb44=resultsPCA4$rotation[, 1:5]
pb66=resultsPCA6$rotation[, 1:5]

PCA2B2 = pb22 %*% solve(t(pb22) %*% pb22) %*% t(pb22) - B %*% solve(t(B) %*% B) %*% t(B)
PCA2B4 = pb44 %*% solve(t(pb44) %*% pb44) %*% t(pb44) - B %*% solve(t(B) %*% B) %*% t(B)
PCA2B6 = pb66 %*% solve(t(pb66) %*% pb66) %*% t(pb66) - B %*% solve(t(B) %*% B) %*% t(B)



pl2=simPls2$projection[, 1]
pl4=simPls4$projection[, 1]
pl6=simPls6$projection[, 1]

PLB2 = pl2 %*% solve(t(pl2) %*% pl2) %*% t(pl2) - B %*% solve(t(B) %*% B) %*% t(B)
PLB4 = pl4 %*% solve(t(pl4) %*% pl4) %*% t(pl4) - B %*% solve(t(B) %*% B) %*% t(B)
PLB6 = pl6 %*% solve(t(pl6) %*% pl6) %*% t(pl6) - B %*% solve(t(B) %*% B) %*% t(B)



a2 = W2[, 1:3]
a4 = W4[, 1]
a6 = W6[, 1]

AS2 = a2 %*% solve(t(a2) %*% a2) %*% t(a2) - B %*% solve(t(B) %*% B) %*% t(B)
AS4 = a4 %*% solve(t(a4) %*% a4) %*% t(a4) - B %*% solve(t(B) %*% B) %*% t(B)
AS6 = a6 %*% solve(t(a6) %*% a6) %*% t(a6) - B %*% solve(t(B) %*% B) %*% t(B)

gKDRB2 = g2data %*% solve(t(g2data) %*% g2data) %*% t(g2data) - B %*% solve(t(B) %*% B) %*% t(B)
gKDRB4 = g4data %*% solve(t(g4data) %*% g4data) %*% t(g4data) - B %*% solve(t(B) %*% B) %*% t(B)
gKDRB6 = g6data %*% solve(t(g6data) %*% g6data) %*% t(g6data) - B %*% solve(t(B) %*% B) %*% t(B)


gKDRiB2 = gi2data %*% solve(t(gi2data) %*% gi2data) %*% t(gi2data) - B %*% solve(t(B) %*% B) %*% t(B)
gKDRiB4 = gi4data %*% solve(t(gi4data) %*% gi4data) %*% t(gi4data) - B %*% solve(t(B) %*% B) %*% t(B)
gKDRiB6 = gi6data %*% solve(t(gi6data) %*% gi6data) %*% t(gi6data) - B %*% solve(t(B) %*% B) %*% t(B)


gKDRvB2 = gv2data %*% solve(t(gv2data) %*% gv2data) %*% t(gv2data) - B %*% solve(t(B) %*% B) %*% t(B)
gKDRvB4 = gv4data %*% solve(t(gv4data) %*% gv4data) %*% t(gv4data) - B %*% solve(t(B) %*% B) %*% t(B)
gKDRvB6 = gv6data %*% solve(t(gv6data) %*% gv6data) %*% t(gv6data) - B %*% solve(t(B) %*% B) %*% t(B)


p8=c(Frobenius_norm(PCAB2), Frobenius_norm(PCAB4), Frobenius_norm(PCAB6))
p2=c(Frobenius_norm(PCA2B2), Frobenius_norm(PCA2B4), Frobenius_norm(PCA2B6))
pl=c(Frobenius_norm(PLB2), Frobenius_norm(PLB4), Frobenius_norm(PLB6))
acti=c(Frobenius_norm(AS2), Frobenius_norm(AS4), Frobenius_norm(AS6))
g1=c(Frobenius_norm(gKDRB2), Frobenius_norm(gKDRB4), Frobenius_norm(gKDRB6))
gi1=c(Frobenius_norm(gKDRiB2), Frobenius_norm(gKDRiB4), Frobenius_norm(gKDRiB6))
gv1=c(Frobenius_norm(gKDRvB2), Frobenius_norm(gKDRvB4), Frobenius_norm(gKDRvB6))

p8
p2
pl
acti
g1
gi1
gv1

```







